# modify_image — Edit an image using Gemini via the Nano Banana workflow.
#
# Usage:
#   modify_image <source_image> <prompt> <output_image> [aspect_ratio]
#
# Arguments:
#   source_image   Path to the source image (png, webp, jpg/jpeg)
#   prompt         The edit instruction for Gemini
#   output_image   Path for the final .webp output
#   aspect_ratio   Optional (e.g., "4:3", "16:9"). Omit to skip.
#
# Requires:
#   - GEMINI_API_KEY environment variable
#   - curl, jq, base64 on PATH
#   - extract_image and convert_to_webp commands

set -euo pipefail

ENDPOINT="https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent"

if [[ $# -lt 3 ]]; then
  echo "Usage: $0 <source_image> <prompt> <output_image> [aspect_ratio]" >&2
  exit 1
fi

SOURCE_IMAGE="$1"
PROMPT="$2"
OUTPUT_IMAGE="$3"
ASPECT_RATIO="${4:-}"

if [[ -z "${GEMINI_API_KEY:-}" ]]; then
  echo "Error: GEMINI_API_KEY is not set." >&2
  exit 1
fi

if [[ ! -f "$SOURCE_IMAGE" ]]; then
  echo "Error: Source image not found: $SOURCE_IMAGE" >&2
  exit 1
fi

# Detect mime type from extension
EXT="${SOURCE_IMAGE##*.}"
case "${EXT,,}" in
  png)          MIME="image/png" ;;
  webp)         MIME="image/webp" ;;
  jpg|jpeg)     MIME="image/jpeg" ;;
  *)            echo "Error: Unsupported image format: $EXT" >&2; exit 1 ;;
esac

# Temp files (cleaned up on exit)
B64_FILE="$(mktemp /tmp/nb_b64.XXXXXX)"
RESP_FILE="$(mktemp /tmp/nb_resp.XXXXXX.json)"
PNG_FILE="$(mktemp /tmp/nb_out.XXXXXX.png)"
trap 'rm -f "$B64_FILE" "$RESP_FILE" "$PNG_FILE"' EXIT

# 1. Encode source image to a temp file (NOT a shell variable — too large)
base64 -w0 "$SOURCE_IMAGE" > "$B64_FILE"

# 2. Build request JSON with jq, reading base64 from the temp file
IMAGE_CONFIG=""
if [[ -n "$ASPECT_RATIO" ]]; then
  IMAGE_CONFIG=$(jq -n --arg ar "$ASPECT_RATIO" '{"aspectRatio": $ar, "imageSize": "2K"}')
else
  IMAGE_CONFIG='{"imageSize": "2K"}'
fi

jq -Rs \
  --arg prompt "$PROMPT" \
  --arg mime "$MIME" \
  --argjson imgcfg "$IMAGE_CONFIG" \
  '{
    "contents": [{"parts": [
      {"text": $prompt},
      {"inline_data": {"mime_type": $mime, "data": .}}
    ]}],
    "generationConfig": {
      "responseModalities": ["TEXT", "IMAGE"],
      "imageConfig": $imgcfg
    }
  }' < "$B64_FILE" \
  | curl -s -X POST "$ENDPOINT" \
      -H "x-goog-api-key: ${GEMINI_API_KEY}" \
      -H "Content-Type: application/json" \
      -d @- -o "$RESP_FILE"

# 3. Extract image from response (handles sanitization, error checking, field name variants)
extract_image "$RESP_FILE" "$PNG_FILE"

# 4. Convert to webp
convert_to_webp "$PNG_FILE" "$OUTPUT_IMAGE"

echo "Saved edited image to: $OUTPUT_IMAGE"

